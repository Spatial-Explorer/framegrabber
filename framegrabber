#!/bin/bash
#
# framegrabber-v1
# Extract first/last frames or all frames from a video.
# Features: --outdir, --jpg/--png, --force, --quiet, sudo-fallback for outdir,
#           --install / --uninstall (macOS-aware), --all for full extraction,
#           --wav and --no-audio for audio extraction options.
#
# Requires: ffmpeg

set -euo pipefail

APP_NAME="framegrabber"
VERSION="v1"

show_help() {
  cat <<'EOF'
Usage:
  framegrabber -v <video-file> [options]

(framegrabber ${VERSION})

Extracts frames from a video file.

By default extracts only the FIRST and LAST frames.
Use --all to extract EVERY frame as sequentially numbered files.

Options:
  -v, --video FILE     Path to the video file (required)
      --outdir DIR     Directory to save output files (default: ./output)
      --jpg            Save output as .jpg instead of .png
      --png            Save output as .png (default)
      --all            Extract every frame (named <name>-000001.<ext>, ...)
      --force          Overwrite existing files without asking
  -q, --quiet          Quiet mode: suppress prompts and non-essential output
                       (implies --force). If --outdir cannot be created,
                       falls back silently to ./output.
      --wav            Extract audio as lossless WAV instead of MP3
      --copy-audio     Extract audio without re-encoding (bitstream copy; auto-detects extension like .m4a/.mp3/.flac/.opus/.ogg/.ac3/.wav)
      --audio FORMAT   Choose audio mode: mp3 (default) | wav | copy
      --no-audio       Do not extract audio
  -h, --help           Show this help message

Maintenance:
      --install        Install this script globally (macOS: /usr/local/bin or /opt/homebrew/bin)
      --uninstall      Remove global installation

Examples:
  framegrabber -v movie.mp4
  framegrabber -v clip.mp4 --jpg --outdir ~/frames
  framegrabber -v demo.mp4 --quiet
  framegrabber -v movie.mp4 --all --jpg --outdir ~/frames
  framegrabber --install
  framegrabber --uninstall
EOF
}

need() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Error: $1 is not installed or not on PATH." >&2
    exit 1
  fi
}

# -------- Path resolution helpers --------
resolve_script_path() {
  local src="${BASH_SOURCE[0]}"
  while [ -h "$src" ]; do
    local dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  cd -P "$(dirname "$src")" >/dev/null 2>&1
  pwd
}

script_dir="$(resolve_script_path)"
script_src="$script_dir/$(basename "${BASH_SOURCE[0]}")"

# Normalize arguments: replace Unicode dashes with ASCII '-' and split --key=value
norm_args=()
for arg in "$@"; do
  # Use perl to handle Unicode dashes reliably across macOS/BSD
  fixed="$(printf '%s' "$arg" | perl -CSDA -pe 's/[\x{2010}-\x{2015}\x{2212}\x{FE58}\x{FE63}\x{FF0D}]/-/g')"
  # Split --key=value into two args
  if [[ "$fixed" == --*=* ]]; then
    k="${fixed%%=*}"
    v="${fixed#*=}"
    norm_args+=("$k" "$v")
  else
    norm_args+=("$fixed")
  fi
done
set -- "${norm_args[@]}"

# -------- Install / Uninstall --------
detect_install_dir() {
  if [[ -d /usr/local/bin && -w /usr/local/bin ]]; then
    echo "/usr/local/bin"; return
  fi
  if [[ -d /opt/homebrew/bin && -w /opt/homebrew/bin ]]; then
    echo "/opt/homebrew/bin"; return
  fi
  if [[ -d /usr/local/bin ]]; then
    echo "/usr/local/bin"; return
  fi
  if [[ -d /opt/homebrew/bin ]]; then
    echo "/opt/homebrew/bin"; return
  fi
  echo "$HOME/.local/bin"
}

do_install() {
  local dest_dir target
  dest_dir="$(detect_install_dir)"
  target="$dest_dir/$APP_NAME"

  if [[ "$dest_dir" == "$HOME/.local/bin" ]]; then
    mkdir -p "$dest_dir"
    cp "$script_src" "$target"
    chmod 0755 "$target"
    echo "✅ Installed to $target"
  else
    echo "Installing to $target (may require sudo)..."
    if install -m 0755 "$script_src" "$target" 2>/dev/null; then
      echo "✅ Installed to $target"
    else
      sudo install -m 0755 "$script_src" "$target"
      echo "✅ Installed to $target"
    fi
  fi

  case ":$PATH:" in
    *:"$dest_dir":*) ;;
    *) echo "⚠️  Note: $dest_dir is not on your PATH.
    Add this to your shell profile (e.g., ~/.zshrc):
      export PATH=\"$dest_dir:\$PATH\"";;
  esac
}

do_uninstall() {
  local removed=false
  for d in /usr/local/bin /opt/homebrew/bin "$HOME/.local/bin"; do
    if [[ -f "$d/$APP_NAME" ]]; then
      echo "Removing $d/$APP_NAME (may require sudo)..."
      if rm -f "$d/$APP_NAME" 2>/dev/null; then
        echo "✅ Removed $d/$APP_NAME"
      else
        sudo rm -f "$d/$APP_NAME"
        echo "✅ Removed $d/$APP_NAME"
      fi
      removed=true
    fi
  done
  $removed || echo "No global installation of '$APP_NAME' found."
}

case "${1:-}" in
  --install)   do_install; exit 0 ;;
  --uninstall) do_uninstall; exit 0 ;;
  --version)   echo "${APP_NAME} ${VERSION}"; exit 0 ;;
  --where)     echo "${script_src}"; exit 0 ;;

esac

# -------- Main functionality --------
need ffmpeg
need ffprobe

VIDEO_FILE=""
OUTDIR="./output"
EXT="png"
FORCE=false
QUIET=false
ALL_FRAMES=false
AUDIO_FORMAT="mp3"
NO_AUDIO=false

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    -v|--video) VIDEO_FILE="${2:-}"; shift 2 ;;
    --outdir)   OUTDIR="${2:-}"; shift 2 ;;
    --jpg)      EXT="jpg"; shift ;;
    --png)      EXT="png"; shift ;;
    --all)      ALL_FRAMES=true; shift ;;
    --force)    FORCE=true; shift ;;
    -q|--quiet) QUIET=true; FORCE=true; shift ;;
    --wav)      AUDIO_FORMAT="wav"; shift ;;
    --copy-audio) AUDIO_FORMAT="copy"; shift ;;
    --copyaudio|--copy_audio) AUDIO_FORMAT="copy"; shift ;;
    --audio)    AUDIO_FORMAT="${2:-}"; shift 2 ;;
    --no-audio) NO_AUDIO=true; shift ;;
    -h|--help)  show_help; exit 0 ;;
    *) echo "Unknown option: $1" >&2; show_help; exit 1 ;;
  esac
done

echo_info() { $QUIET || echo "$@"; }
echo_warn() { $QUIET || echo "Warning: $*" >&2; }

[[ -z "$VIDEO_FILE" ]] && { echo "Error: video file required" >&2; show_help; exit 1; }
[[ ! -f "$VIDEO_FILE" ]] && { echo "Error: file not found: $VIDEO_FILE" >&2; exit 1; }

# Expand ~ and normalize OUTDIR
OUTDIR=$(eval echo "$OUTDIR")

# Try to create OUTDIR (with sudo fallback unless quiet)
if ! mkdir -p "$OUTDIR" 2>/dev/null; then
  if $QUIET; then
    OUTDIR="./output"; mkdir -p "$OUTDIR"
  else
    echo_warn "Unable to create directory '$OUTDIR' (permission denied or read-only)."
    while true; do
      read -r -p "Try with sudo? (y/N) " ans
      case "$ans" in
        [Yy]* )
          if sudo mkdir -p "$OUTDIR" && sudo chown "$USER:$USER" "$OUTDIR"; then
            echo_info "Directory created with sudo: $OUTDIR"; break
          else
            echo_warn "Failed to create '$OUTDIR' with sudo."
            echo_info "Falling back to ./output"; OUTDIR="./output"; mkdir -p "$OUTDIR"; break
          fi ;;
        [Nn]*|"" )
          echo_info "Falling back to ./output"; OUTDIR="./output"; mkdir -p "$OUTDIR"; break ;;
        * ) echo "Please answer y or n." ;;
      esac
    done
  fi
fi

base="$(basename -- "$VIDEO_FILE")"
name="${base%.*}"
out_first="${OUTDIR}/${name}-first.${EXT}"
out_last="${OUTDIR}/${name}-last.${EXT}"

confirm_overwrite() {
  local f="$1"
  if [[ -e "$f" && "$FORCE" = false ]]; then
    while true; do
      read -r -p "File '$f' exists. Overwrite? [y/N] " ans
      case "$ans" in
        [Yy]*) return 0 ;;
        [Nn]*|"") return 1 ;;
        *) echo "Please answer y or n." ;;
      esac
    done
  fi
  return 0
}

# --- Audio helpers ---
detect_audio_codec() {
  ffprobe -v error -select_streams a:0 -show_entries stream=codec_name \
    -of default=noprint_wrappers=1:nokey=1 "$VIDEO_FILE" 2>/dev/null | head -n1
}

ext_for_copy_codec() {
  local c="$1"
  case "$c" in
    aac|aac*)   echo "m4a" ;;
    alac)       echo "m4a" ;;
    mp3|mp2|mp1) echo "mp3" ;;
    flac)       echo "flac" ;;
    opus)       echo "opus" ;;
    vorbis)     echo "ogg" ;;
    ac3)        echo "ac3" ;;
    eac3)       echo "eac3" ;;
    pcm_*|pcm*) echo "wav" ;;
    *)          echo "mka" ;;
  esac
}

if $ALL_FRAMES; then
  out_pattern="${OUTDIR}/${name}-%06d.${EXT}"
  # If any matching files exist, confirm once (unless --force/--quiet)
  if compgen -G "${OUTDIR}/${name}-*.${EXT}" > /dev/null; then
    if ! $FORCE; then
      while true; do
        read -r -p "Matching files '${OUTDIR}/${name}-*.${EXT}' exist. Overwrite? [y/N] " ans
        case "$ans" in
          [Yy]*) break ;;
          [Nn]*|"" ) echo_info "Skipping all-frames extraction."; exit 0 ;;
          * ) echo "Please answer y or n." ;;
        esac
      done
    fi
  fi
  ffmpeg -hide_banner -loglevel error -y -i "$VIDEO_FILE" "$out_pattern"
  echo_info "Wrote all frames to ${OUTDIR}/ (pattern: $(basename "${name}")-%06d.${EXT})"
else
  # First frame
  if confirm_overwrite "$out_first"; then
    ffmpeg -hide_banner -loglevel error -y -i "$VIDEO_FILE" -frames:v 1 "$out_first"
    echo_info "Wrote $out_first"
  else
    echo_info "Skipped $out_first"
  fi

  # Last frame
  if confirm_overwrite "$out_last"; then
    ffmpeg -hide_banner -loglevel error -y -sseof -0.1 -i "$VIDEO_FILE" -frames:v 1 "$out_last"
    echo_info "Wrote $out_last"
  else
    echo_info "Skipped $out_last"
  fi
fi

# Audio extraction
if ! $NO_AUDIO; then
  audio_codec="$(detect_audio_codec)"
  if [[ -z "$audio_codec" ]]; then
    echo_info "No audio stream detected; skipping audio extraction"
  else
    # Determine output path according to requested format
    if [[ "$AUDIO_FORMAT" == "wav" ]]; then
      out_audio="${OUTDIR}/${name}.wav"
      if confirm_overwrite "$out_audio"; then
        set +e
        ffmpeg -hide_banner -loglevel error -y -i "$VIDEO_FILE" -vn -map 0:a:0 -c:a pcm_s16le "$out_audio"
        status=$?
        set -e
        if [[ $status -eq 0 ]]; then
          echo_info "Wrote audio to $out_audio"
        else
          echo_warn "Audio extraction (wav) failed."
        fi
      else
        echo_info "Skipped audio extraction"
      fi
    elif [[ "$AUDIO_FORMAT" == "copy" || "$AUDIO_FORMAT" == "COPY" ]]; then
      ext="$(ext_for_copy_codec "$audio_codec")"
      out_audio="${OUTDIR}/${name}.${ext}"
      if confirm_overwrite "$out_audio"; then
        set +e
        ffmpeg -hide_banner -loglevel error -y -i "$VIDEO_FILE" -vn -map 0:a:0 -c:a copy "$out_audio"
        status=$?
        set -e
        if [[ $status -eq 0 ]]; then
          echo_info "Wrote audio (copy, codec=$audio_codec) to $out_audio"
        else
          echo_warn "Bitstream copy failed; try without --copy-audio or use --wav/--mp3."
        fi
      else
        echo_info "Skipped audio extraction"
      fi
    else
      # default mp3
      out_audio="${OUTDIR}/${name}.mp3"
      if confirm_overwrite "$out_audio"; then
        set +e
        ffmpeg -hide_banner -loglevel error -y -i "$VIDEO_FILE" -vn -map 0:a:0 -c:a libmp3lame -q:a 2 "$out_audio"
        status=$?
        set -e
        if [[ $status -eq 0 ]]; then
          echo_info "Wrote audio to $out_audio"
        else
          echo_warn "Audio extraction (mp3) failed."
        fi
      else
        echo_info "Skipped audio extraction"
      fi
    fi
  fi
fi

$QUIET || echo "✅ Done."
