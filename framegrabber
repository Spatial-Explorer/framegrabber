#!/bin/bash
#
# framegrabber-v1
# Extract first/last frames or all frames from a video.
# Features: --outdir, --jpg/--png, --force, --quiet, sudo-fallback for outdir,
#           --install / --uninstall (macOS-aware), --all for full extraction.
#
# Requires: ffmpeg

set -euo pipefail

APP_NAME="framegrabber"

show_help() {
  cat <<'EOF'
Usage:
  framegrabber -v <video-file> [options]

Extracts frames from a video file.

By default extracts only the FIRST and LAST frames.
Use --all to extract EVERY frame as sequentially numbered files.

Options:
  -v, --video FILE     Path to the video file (required)
      --outdir DIR     Directory to save output files (default: ./output)
      --jpg            Save output as .jpg instead of .png
      --png            Save output as .png (default)
      --all            Extract every frame (named <name>-000001.<ext>, ...)
      --force          Overwrite existing files without asking
  -q, --quiet          Quiet mode: suppress prompts and non-essential output
                       (implies --force). If --outdir cannot be created,
                       falls back silently to ./output.
  -h, --help           Show this help message

Maintenance:
      --install        Install this script globally (macOS: /usr/local/bin or /opt/homebrew/bin)
      --uninstall      Remove global installation

Examples:
  framegrabber -v movie.mp4
  framegrabber -v clip.mp4 --jpg --outdir ~/frames
  framegrabber -v demo.mp4 --quiet
  framegrabber -v movie.mp4 --all --jpg --outdir ~/frames
  framegrabber --install
  framegrabber --uninstall
EOF
}

need() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Error: $1 is not installed or not on PATH." >&2
    exit 1
  fi
}

# -------- Path resolution helpers --------
resolve_script_path() {
  local src="${BASH_SOURCE[0]}"
  while [ -h "$src" ]; do
    local dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  cd -P "$(dirname "$src")" >/dev/null 2>&1
  pwd
}

script_dir="$(resolve_script_path)"
script_src="$script_dir/$(basename "${BASH_SOURCE[0]}")"

# -------- Install / Uninstall --------
detect_install_dir() {
  if [[ -d /usr/local/bin && -w /usr/local/bin ]]; then
    echo "/usr/local/bin"; return
  fi
  if [[ -d /opt/homebrew/bin && -w /opt/homebrew/bin ]]; then
    echo "/opt/homebrew/bin"; return
  fi
  if [[ -d /usr/local/bin ]]; then
    echo "/usr/local/bin"; return
  fi
  if [[ -d /opt/homebrew/bin ]]; then
    echo "/opt/homebrew/bin"; return
  fi
  echo "$HOME/.local/bin"
}

do_install() {
  local dest_dir target
  dest_dir="$(detect_install_dir)"
  target="$dest_dir/$APP_NAME"

  if [[ "$dest_dir" == "$HOME/.local/bin" ]]; then
    mkdir -p "$dest_dir"
    cp "$script_src" "$target"
    chmod 0755 "$target"
    echo "✅ Installed to $target"
  else
    echo "Installing to $target (may require sudo)..."
    if install -m 0755 "$script_src" "$target" 2>/dev/null; then
      echo "✅ Installed to $target"
    else
      sudo install -m 0755 "$script_src" "$target"
      echo "✅ Installed to $target"
    fi
  fi

  case ":$PATH:" in
    *:"$dest_dir":*) ;;
    *) echo "⚠️  Note: $dest_dir is not on your PATH.
    Add this to your shell profile (e.g., ~/.zshrc):
      export PATH=\"$dest_dir:\$PATH\"";;
  esac
}

do_uninstall() {
  local removed=false
  for d in /usr/local/bin /opt/homebrew/bin "$HOME/.local/bin"; do
    if [[ -f "$d/$APP_NAME" ]]; then
      echo "Removing $d/$APP_NAME (may require sudo)..."
      if rm -f "$d/$APP_NAME" 2>/dev/null; then
        echo "✅ Removed $d/$APP_NAME"
      else
        sudo rm -f "$d/$APP_NAME"
        echo "✅ Removed $d/$APP_NAME"
      fi
      removed=true
    fi
  done
  $removed || echo "No global installation of '$APP_NAME' found."
}

case "${1:-}" in
  --install)   do_install; exit 0 ;;
  --uninstall) do_uninstall; exit 0 ;;
esac

# -------- Main functionality --------
need ffmpeg

VIDEO_FILE=""
OUTDIR="./output"
EXT="png"
FORCE=false
QUIET=false
ALL_FRAMES=false

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    -v|--video) VIDEO_FILE="${2:-}"; shift 2 ;;
    --outdir)   OUTDIR="${2:-}"; shift 2 ;;
    --jpg)      EXT="jpg"; shift ;;
    --png)      EXT="png"; shift ;;
    --all)      ALL_FRAMES=true; shift ;;
    --force)    FORCE=true; shift ;;
    -q|--quiet) QUIET=true; FORCE=true; shift ;;
    -h|--help)  show_help; exit 0 ;;
    *) echo "Unknown option: $1" >&2; show_help; exit 1 ;;
  esac
done

echo_info() { $QUIET || echo "$@"; }
echo_warn() { $QUIET || echo "Warning: $*" >&2; }

[[ -z "$VIDEO_FILE" ]] && { echo "Error: video file required" >&2; show_help; exit 1; }
[[ ! -f "$VIDEO_FILE" ]] && { echo "Error: file not found: $VIDEO_FILE" >&2; exit 1; }

# Expand ~ and normalize OUTDIR
OUTDIR=$(eval echo "$OUTDIR")

# Try to create OUTDIR (with sudo fallback unless quiet)
if ! mkdir -p "$OUTDIR" 2>/dev/null; then
  if $QUIET; then
    OUTDIR="./output"; mkdir -p "$OUTDIR"
  else
    echo_warn "Unable to create directory '$OUTDIR' (permission denied or read-only)."
    while true; do
      read -r -p "Try with sudo? (y/N) " ans
      case "$ans" in
        [Yy]* )
          if sudo mkdir -p "$OUTDIR" && sudo chown "$USER:$USER" "$OUTDIR"; then
            echo_info "Directory created with sudo: $OUTDIR"; break
          else
            echo_warn "Failed to create '$OUTDIR' with sudo."
            echo_info "Falling back to ./output"; OUTDIR="./output"; mkdir -p "$OUTDIR"; break
          fi ;;
        [Nn]*|"" )
          echo_info "Falling back to ./output"; OUTDIR="./output"; mkdir -p "$OUTDIR"; break ;;
        * ) echo "Please answer y or n." ;;
      esac
    done
  fi
fi

base="$(basename -- "$VIDEO_FILE")"
name="${base%.*}"
out_first="${OUTDIR}/${name}-first.${EXT}"
out_last="${OUTDIR}/${name}-last.${EXT}"

confirm_overwrite() {
  local f="$1"
  if [[ -e "$f" && "$FORCE" = false ]]; then
    while true; do
      read -r -p "File '$f' exists. Overwrite? [y/N] " ans
      case "$ans" in
        [Yy]*) return 0 ;;
        [Nn]*|"") return 1 ;;
        *) echo "Please answer y or n." ;;
      esac
    done
  fi
  return 0
}

if $ALL_FRAMES; then
  out_pattern="${OUTDIR}/${name}-%06d.${EXT}"
  # If any matching files exist, confirm once (unless --force/--quiet)
  if compgen -G "${OUTDIR}/${name}-*.${EXT}" > /dev/null; then
    if ! $FORCE; then
      while true; do
        read -r -p "Matching files '${OUTDIR}/${name}-*.${EXT}' exist. Overwrite? [y/N] " ans
        case "$ans" in
          [Yy]*) break ;;
          [Nn]*|"" ) echo_info "Skipping all-frames extraction."; exit 0 ;;
          * ) echo "Please answer y or n." ;;
        esac
      done
    fi
  fi
  ffmpeg -hide_banner -loglevel error -y -i "$VIDEO_FILE" "$out_pattern"
  echo_info "Wrote all frames to ${OUTDIR}/ (pattern: $(basename "${name}")-%06d.${EXT})"
else
  # First frame
  if confirm_overwrite "$out_first"; then
    ffmpeg -hide_banner -loglevel error -y -i "$VIDEO_FILE" -frames:v 1 "$out_first"
    echo_info "Wrote $out_first"
  else
    echo_info "Skipped $out_first"
  fi

  # Last frame
  if confirm_overwrite "$out_last"; then
    ffmpeg -hide_banner -loglevel error -y -sseof -0.1 -i "$VIDEO_FILE" -frames:v 1 "$out_last"
    echo_info "Wrote $out_last"
  else
    echo_info "Skipped $out_last"
  fi
fi

$QUIET || echo "✅ Done."
